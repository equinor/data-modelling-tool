= Developer Docs
:toc: left
:icons: font
:hide-uri-scheme:
:source-highlighter: rouge

How to get DMT up and running on your local machine for development and testing purposes.

== Repositories

* https://github.com/equinor/data-modelling-tool - The Data Modelling Tool
* https://github.com/equinor/data-modelling-storage-service - Storage Service for documents
* https://github.com/equinor/data-modelling-tool-demo-app - Example of Custom Application
* https://github.com/equinor/dmt-py - Library to talk to the Data Modelling Storage Service directly from Python

== Developing

=== Prerequisites

In order to run DMT you need to have installed:

- https://www.docker.com/[Docker]
- https://docs.docker.com/compose/[Docker Compose]
- Git

=== Installation

Docker-compose is used for running the project locally.

DMT depends on the Data Modelling Storage Service for storing documents and DMSS must be cloned in same directory as DMT, since DMSS is volume mounted inside DMT container at runtime.

[source, bash]
----
git clone git@github.com:equinor/data-modelling-tool.git
git clone git@github.com:equinor/data-modelling-storage service.git
cd data-modelling-tool
----

// == List of files/directory structure

// Optional depending on the complexity of the project

//== Basic installation instructions
// Be brief, provide links to more detailed documentation

//== Basic usage instructions
// Be brief, provide links to more detailed documentation

=== Usage

==== Starting

When running locally, in development mode, DMSS need to be running alongside DMT. Since DMT try to use the same network as DMSS, DMSS needs to be started first.

[source, bash]
----
cd ../data-modelling-storage-service
docker-compose up
cd ../data-modelling-tool
docker-compose up
----

The DMT will be available at http://localhost

==== Stopping

[source, bash]
----
docker-compose down
----

==== Import data and reset database

Import local documents to the configured DMSS_HOST (from /api/home directory).
Token is optional, but required if DMSS is configured with authentication.
Token can be acquired from the DMT Web application .

[source, bash]
----
docker-compose run --rm api reset-app --token=Eyxx.xxxx.xxxx
----

If the data is corrupted or in a bad state some way, a hard reset of the DMSS is often a solution.
This command will remove every _mongo database using the same database host as the core_, and upload DMSS's core documents.
[source, bash]
----
docker-compose run --rm dmss reset-app
----


==== Running Tests

Unit tests:

[source, bash]
----
docker-compose run --rm api pytest
----

BDD tests:

[source, bash]
----
docker-compose run --rm api behave
----

== Tools used

=== Pre-commit

Code is among other things automatically prettified upon commit using precommit hooks.

The project provides a [.pre-commit-config.yaml](.pre-commit-config.yaml) file that is used to setup git _pre-commit hooks_.

[source, bash]
----
pip install pre-commit
pre-commit install
----

Alternative pre-commit installations can be found https://pre-commit.com/#install[here].

== Architecture

[quote, Robert C. Martin]
____
A good architecture emphasis the use-case and decouples them from peripheral concerns.
____

We are using https://c4model.com for showing architecture diagrams.

=== Level 1 - System Context diagram

The Context diagram is a good starting point for diagramming and documenting a software system, allowing you to step back and see the big picture. Here we draw a diagram showing the system as a box in the centre, surrounded by its users and the other systems that it interacts with.

// https://github.com/plantuml-stdlib/C4-PlantUML

[plantuml,,svg]
....
@startuml

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

LAYOUT_WITH_LEGEND()

Person(domain_export, "Domain Expert", "A user that wants to do modelling.")
Person(application_developer, "Application Developer", "A user that wants to develop custom applications.")
Person(application_users, "Application User", "A user that wants to use custom applications.")

System(data_modelling_tool, "Data Modelling Tool", "A tool for modelling, searching, and viewing blueprint based domain models.")

System_Ext(data_modelling_storage_service, "Data Modelling Storage Service System", "Handles the storing and retrieving of data.")

Rel(domain_export, data_modelling_tool, "Uses")
Rel(application_developer, data_modelling_tool, "Uses")
Rel(application_users, data_modelling_tool, "Uses")

Rel(data_modelling_tool, data_modelling_storage_service, "Read and write")

ContainerDb(data_source_a, "Data Source A", "MongoDB", "Holds documents (e.g. blueprints and entities).")
ContainerDb(data_source_b, "Data Source B", "Azure Blob Storage", "Holds different type of data.")
Rel(data_modelling_storage_service, data_source_a, "Read and write")
Rel(data_modelling_storage_service, data_source_b, "Read and write")

@enduml
....

=== Level 2 - Container diagram

Once you understand how your system fits in to the overall IT environment, a really useful next step is to zoom-in to the system boundary with a Container diagram. A container is something like a server-side web application, single-page application, desktop application, mobile app, database schema, file system, etc. Essentially, a container is a separately runnable/deployable unit (e.g. a separate process space) that executes code or stores data.

[plantuml,,svg]
....
@startuml

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

LAYOUT_WITH_LEGEND()

Person(domain_export, "Domain Expert", "A user that wants to do modelling.")
Person(application_developer, "Application Developer", "A user that wants to develop custom applications.")
Person(application_users, "Application User", "A user that wants to use custom applications.")

System_Boundary(data_modelling_tool, "Data Modelling Tool") {
    Container(data_modelling_tool_web, "Web application", "JavaScript and React", "The user interface used for modelling, searching, and viewing blueprint based domain models.")
    Container(data_modelling_tool_api, "Rest API", "Python and Flask", "The API that handles business logic for DMT.")
    Rel(data_modelling_tool_web, data_modelling_tool_api, "Uses")
}

Rel(domain_export, data_modelling_tool_web, "Uses")
Rel(application_developer, data_modelling_tool_web, "Uses")
Rel(application_users, data_modelling_tool_web, "Uses")

Container_Ext(data_modelling_storage_service, "Data Modelling Storage Service System", "Python and Flask", "Handles the storing and retrieving of data.")
Rel(data_modelling_tool_api, data_modelling_storage_service, "Read and write")

ContainerDb(data_source_a, "Data Source A", "MongoDB", "Holds documents (e.g. blueprints and entities).")
ContainerDb(data_source_b, "Data Source B", "Azure Blob Storage", "Holds different type of data.")
Rel(data_modelling_storage_service, data_source_a, "Read and write")
Rel(data_modelling_storage_service, data_source_b, "Read and write")

@enduml
....


=== Level 3 - Component diagram

Following on from a Container Diagram, next you can zoom in and decompose each container further to identify the major structural building blocks and their interactions.

The Component diagram shows how a container is made up of a number of components, what each of those components are, their responsibilities and the technology/implementation details.

==== API Architecture

We follow xref:clean-architecture.adoc[the Clean Architecture] style and structure the codebase accordingly for our API's.

This diagram is showing the flow (rather than all) of the components within the APIs.

[plantuml,,svg]
....
@startuml

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

LAYOUT_WITH_LEGEND()

System(web, "Web application", "A web application that interacts with the API.")

System_Boundary(api, "API") {
   Container(controllers, "Controllers", "Function", "Trigger use cases and returning the result.")
   Container(use_cases, "Use Cases", "Class", "Implement and encapsulate all of the business rules.")
   Container(services, "Services", "Interface", "Services to handle application business logic")
   Container(repositories, "Repositories", "Interface", "Handle logic against storage media")

   Rel(controllers, use_cases, "Execute")
   Rel(use_cases, services, "Uses")
   Rel(services, repositories, "Uses")
}

Rel(web, controllers, "Uses")

ContainerDb(data_source_a, "Data Source A", "MongoDB", "Holds documents (e.g. blueprints and entities).")
ContainerDb(data_source_b, "Data Source B", "Azure Blob Storage", "Holds different type of data.")
Rel(repositories, data_source_a, "Read and write")
Rel(repositories, data_source_b, "Read and write")

@enduml
....

The flow:

[mermaid,,]
....
sequenceDiagram
Web Application->>+Controller: request
Controller->>Repository: init
Repository-->>Controller: return instance
Controller->>Service: init
Service-->>Controller: return instance
Controller->>Use Case: init
Use Case-->>Controller: return instance
Controller->>Use Case: execute use case
Use Case->>+Service: do action
Service->>+Repository: do action
Repository-->>-Service: return
Service-->>-Use Case: return
Use Case-->>Controller: return
Controller->>-Web Application: return result
....

=== Current architecture status

The long term goal of Data Modelling Tool is to have a federated, standardized, and well defined StorageService that can handle the storing and retrieving of data of different nature and requirements.

For this to work, we need some components with responsibility of different layers of abstraction. All these components will need to support basic CRUD (crate, read, update, delete) functionality.

image::images/architecture.png[]

[plantuml,,svg]
....
@startuml

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

LAYOUT_WITH_LEGEND()

Person(domain_export, "Domain Expert", "A user that wants to do modelling.")
Person(application_developer, "Application Developer", "A user that wants to develop custom applications.")
Person(application_users, "Application User", "A user that wants to use custom applications.")

System(data_modelling_tool, "Data Modelling Tool", "A tool for modelling, searching, and viewing blueprint based domain models.")

Rel(domain_export, data_modelling_tool, "Uses")
Rel(application_developer, data_modelling_tool, "Uses")
Rel(application_users, data_modelling_tool, "Uses")

System_Ext(data_modelling_storage_service, "Data Modelling Storage Service System", "Handles the storing and retrieving of data.")
Rel(data_modelling_tool, data_modelling_storage_service, "Read and write")

System_Ext(data_source_a, "Data Source", "The first data source that has it's own storage options.")

System_Ext(data_source_b, "Data Source", "The second data source that has it's own storage options.")

Rel(data_modelling_storage_service, data_source_a, "Read and write")
Rel(data_modelling_storage_service, data_source_b, "Read and write")

ContainerDb(db_a, "MongoDB", "The first db.")
ContainerDb(db_b, "PostgresQL", "The second db.")
ContainerDb(db_c, "Azure Blob Storage", "The third db.")

Rel(data_source_a, db_a, "Read and write")
Rel(data_source_a, db_b, "Read and write")
Rel(data_source_a, db_c, "Read and write")

ContainerDb(db_d, "MongoDB", "The first db.")
Rel(data_source_b, db_d, "Read and write")

@enduml
....


*DocumentService (Data Modelling Storage Service):*

The Data Modelling Storage Service will get requests like `Fetch document with id 8962045 from the Data Source A`.
 This can be a complex document, containing references to documents in different DataSources. It will then be Data Modelling Storage Service's job to construct this document in it's entirety.

*DataSource:*

The DataSource, and components to the left of the DataSource, are the "self-hosted" components. Different organizations can setup their own DataSource, which they can control access to.
The job of the DataSource is to determine which storage backend (Repository) should be used for the data.
 Here, there are no complex documents, but the DataSource will make choices based on the StorageRecipe tied to the data.
Requests coming into the DataSource will look something like this; `Fetch document with id 8962045`.

*Repository:*

This is a plugin based component, that has one interface towards the DataSource, and one to the given storage driver(MongoDB, Postgress, AzureFiles, e.g.)


- [x] DocumentService; CRUD on complex documents in the same DataSource
- [x] Repository; MongoDB Repository plugin
- [ ] DocumentService; CRUD on complex documents from different DataSources
- [x] DataSource: One DataSource can have more than one Repository
- [x] DataSource: Considers storage preferences based on StorageRecipe
- [ ] DataSource: Supports streaming data

== Project structure

=== Web

```
/web
└── /src
    └── /components
    └── /context
    └── /fonts
    └── /hooks
    └── /pages
    └── /services
    └── /utils
    /plugins
```

==== Components

Re-usable components that only display data and handle user events (from keypresses, button clicks, hover states, etc).

The components folder contains a collection of UI components like buttons, custom input fields, modals, etc., that will be shared and used across files in the project.

==== Context

Context providers and consumers used in the application.

The hooks used by the provider components (e.g. dashboard and index) are different from the hooks found in the hooks/ directory. The hooks in the hooks/ directory can be used anywhere in the application, and they can be used any number of times. The hooks in the context directory are intended to be used by the provider component only. Using these hooks elsewhere in the application may cause problems as these hooks should not be used more than once in an application.

==== Hooks

At this level, we're often handling concerns like auth, logging, or even more domain-specific things like todos, users, calendar, or even chess. Consider an interaction-layer (useChess) React hook that contained all your chess game logic.

The hooks are the application logic, that is the logic that makes a decision as to what happens next. Some refer to this layer as app logic, which works as well because these are all of the operations of your app. The interaction layer contains the discrete set of commands and queries that your users will carry out.

These are the use cases. Having great visibility into these use cases enables us to get pretty structured with our integration testing as well. We can functionally test every use case with edge cases using Given-When-Then style tests. If you're familiar with Domain-Driven Design concepts, this is the Application Service equivalent. For example for the useTodo hook that provides the function createTodoIfNotExists:

```
Given no todos exist,
when I perform CreateTodo,
then I should see one todo.
```

==== Pages

Controllers (containers) are the top-level components that turn on all the features for a particular page. The pages folder reflects the routes of the application. Each component inside this folder has its own route. A page component will contain children from components folder, parts folder, or its own subfolder. It has its own state, and usually call some services as well.

==== Plugins

See own chapter in xref:user-manual.adoc[user docs] for how to use plugins.

==== Services

Networking and data fetching (infrastructure). Performing API calls and reporting metadata state.

==== Utils

The utils folder is just a place to locate some utility functions that used repeatedly in the project. Files in the utils folder should only contain some functions like date formatting, string conversion, etc.

==== Parts (currently not used)

It contains a reusable components that used in the pages. The difference is that components in parts folder reflect parts of a page, like footer, sidebar, and header, while the components folder contains standalone UI components like button, form, or input field. Sometime, A component in parts can use some components from the components folder.

// == Copyright and licensing information

// == Author(s)

// == Thanks, acknowledgements, and credits

// == Basic contact and help information

// Provide links

// == Bugs

// * List of known bugs
// * Instructions on reporting new bugs

// == Changelog

== How to contribute?

We welcome anyone who would like to join and contribute.

Please see our xref:contribute-guide.adoc[contribute guide].