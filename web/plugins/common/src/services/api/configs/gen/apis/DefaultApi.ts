/* tslint:disable */
/* eslint-disable */
/**
 * Data Modelling Storage Service
 * API for basic data modelling interaction
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ACL,
    ACLFromJSON,
    ACLToJSON,
    AddRootPackageRequest,
    AddRootPackageRequestFromJSON,
    AddRootPackageRequestToJSON,
    DataSourceRequest,
    DataSourceRequestFromJSON,
    DataSourceRequestToJSON,
    GetDocumentResponse,
    GetDocumentResponseFromJSON,
    GetDocumentResponseToJSON,
    HTTPValidationError,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    MoveRequest,
    MoveRequestFromJSON,
    MoveRequestToJSON,
    Reference,
    ReferenceFromJSON,
    ReferenceToJSON,
    RemoveByPathRequest,
    RemoveByPathRequestFromJSON,
    RemoveByPathRequestToJSON,
    RenameRequest,
    RenameRequestFromJSON,
    RenameRequestToJSON,
} from '../models';

export interface ExportRequest {
    absoluteDocumentRef: string;
}

export interface BlobGetByIdRequest {
    dataSourceId: string;
    blobId: string;
}

export interface BlobUploadRequest {
    dataSourceId: string;
    blobId: string;
    file: Blob;
}

export interface BlueprintGetRequest {
    typeRef: string;
}

export interface DataSourceGetRequest {
    dataSourceId: string;
}

export interface DataSourceSaveRequest {
    dataSourceId: string;
    dataSourceRequest: DataSourceRequest;
}

export interface DocumentGetByIdRequest {
    dataSourceId: string;
    documentId: string;
    uiRecipe?: string;
    attribute?: string;
    depth?: number;
}

export interface DocumentGetByPathRequest {
    dataSourceId: string;
    uiRecipe?: string;
    attribute?: string;
    path?: string;
}

export interface DocumentUpdateRequest {
    dataSourceId: string;
    documentId: string;
    data: string;
    updateUncontained?: boolean;
    attribute?: string;
    files?: Array<Blob>;
}

export interface ExplorerAddRequest {
    dataSourceId: string;
    dottedId: string;
    body: object;
    updateUncontained?: boolean;
}

export interface ExplorerAddPackageRequest {
    dataSourceId: string;
    addRootPackageRequest: AddRootPackageRequest;
}

export interface ExplorerAddSimpleRequest {
    dataSourceId: string;
    body: object;
}

export interface ExplorerAddToPathRequest {
    dataSourceId: string;
    document: string;
    directory: string;
    files?: Array<Blob>;
}

export interface ExplorerMoveRequest {
    dataSourceId: string;
    moveRequest: MoveRequest;
}

export interface ExplorerRemoveRequest {
    dataSourceId: string;
    dottedId: string;
}

export interface ExplorerRemoveByPathRequest {
    dataSourceId: string;
    removeByPathRequest: RemoveByPathRequest;
}

export interface ExplorerRenameRequest {
    dataSourceId: string;
    renameRequest: RenameRequest;
}

export interface GetAclRequest {
    dataSourceId: string;
    documentId: string;
}

export interface ReferenceDeleteRequest {
    dataSourceId: string;
    documentDottedId: string;
}

export interface ReferenceInsertRequest {
    dataSourceId: string;
    documentDottedId: string;
    reference: Reference;
}

export interface SearchRequest {
    dataSourceId: string;
    body: object;
    sortByAttribute?: string;
}

export interface SetAclRequest {
    dataSourceId: string;
    documentId: string;
    aCL: ACL;
    recursively?: boolean;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Download a zip-folder of the requested root package
     * Export
     */
    async _exportRaw(requestParameters: ExportRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.absoluteDocumentRef === null || requestParameters.absoluteDocumentRef === undefined) {
            throw new runtime.RequiredError('absoluteDocumentRef','Required parameter requestParameters.absoluteDocumentRef was null or undefined when calling _export.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/export/{absolute_document_ref}`.replace(`{${"absolute_document_ref"}}`, encodeURIComponent(String(requestParameters.absoluteDocumentRef))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download a zip-folder of the requested root package
     * Export
     */
    async _export(requestParameters: ExportRequest): Promise<void> {
        await this._exportRaw(requestParameters);
    }

    /**
     * Get By Id
     */
    async blobGetByIdRaw(requestParameters: BlobGetByIdRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling blobGetById.');
        }

        if (requestParameters.blobId === null || requestParameters.blobId === undefined) {
            throw new runtime.RequiredError('blobId','Required parameter requestParameters.blobId was null or undefined when calling blobGetById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/blobs/{data_source_id}/{blob_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"blob_id"}}`, encodeURIComponent(String(requestParameters.blobId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Get By Id
     */
    async blobGetById(requestParameters: BlobGetByIdRequest): Promise<Blob> {
        const response = await this.blobGetByIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Upload
     */
    async blobUploadRaw(requestParameters: BlobUploadRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling blobUpload.');
        }

        if (requestParameters.blobId === null || requestParameters.blobId === undefined) {
            throw new runtime.RequiredError('blobId','Required parameter requestParameters.blobId was null or undefined when calling blobUpload.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling blobUpload.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        const response = await this.request({
            path: `/api/v1/blobs/{data_source_id}/{blob_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"blob_id"}}`, encodeURIComponent(String(requestParameters.blobId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Upload
     */
    async blobUpload(requestParameters: BlobUploadRequest): Promise<any> {
        const response = await this.blobUploadRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetch the Blueprint of a type (including inherited attributes)
     * Get Blueprint
     */
    async blueprintGetRaw(requestParameters: BlueprintGetRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.typeRef === null || requestParameters.typeRef === undefined) {
            throw new runtime.RequiredError('typeRef','Required parameter requestParameters.typeRef was null or undefined when calling blueprintGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/blueprint/{type_ref}`.replace(`{${"type_ref"}}`, encodeURIComponent(String(requestParameters.typeRef))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Fetch the Blueprint of a type (including inherited attributes)
     * Get Blueprint
     */
    async blueprintGet(requestParameters: BlueprintGetRequest): Promise<object> {
        const response = await this.blueprintGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get
     */
    async dataSourceGetRaw(requestParameters: DataSourceGetRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling dataSourceGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/data-sources/{data_source_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get
     */
    async dataSourceGet(requestParameters: DataSourceGetRequest): Promise<any> {
        const response = await this.dataSourceGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get All
     */
    async dataSourceGetAllRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/data-sources`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get All
     */
    async dataSourceGetAll(): Promise<any> {
        const response = await this.dataSourceGetAllRaw();
        return await response.value();
    }

    /**
     * Create or update a data source configuration
     * Save
     */
    async dataSourceSaveRaw(requestParameters: DataSourceSaveRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling dataSourceSave.');
        }

        if (requestParameters.dataSourceRequest === null || requestParameters.dataSourceRequest === undefined) {
            throw new runtime.RequiredError('dataSourceRequest','Required parameter requestParameters.dataSourceRequest was null or undefined when calling dataSourceSave.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/data-sources/{data_source_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DataSourceRequestToJSON(requestParameters.dataSourceRequest),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Create or update a data source configuration
     * Save
     */
    async dataSourceSave(requestParameters: DataSourceSaveRequest): Promise<any> {
        const response = await this.dataSourceSaveRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get By Id
     */
    async documentGetByIdRaw(requestParameters: DocumentGetByIdRequest): Promise<runtime.ApiResponse<GetDocumentResponse>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling documentGetById.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling documentGetById.');
        }

        const queryParameters: any = {};

        if (requestParameters.uiRecipe !== undefined) {
            queryParameters['ui_recipe'] = requestParameters.uiRecipe;
        }

        if (requestParameters.attribute !== undefined) {
            queryParameters['attribute'] = requestParameters.attribute;
        }

        if (requestParameters.depth !== undefined) {
            queryParameters['depth'] = requestParameters.depth;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/documents/{data_source_id}/{document_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GetDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Get By Id
     */
    async documentGetById(requestParameters: DocumentGetByIdRequest): Promise<GetDocumentResponse> {
        const response = await this.documentGetByIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a document by it\'s path in the form \"{dataSource}/{rootPackage}/{subPackage(s)?/{name}
     * Get By Path
     */
    async documentGetByPathRaw(requestParameters: DocumentGetByPathRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling documentGetByPath.');
        }

        const queryParameters: any = {};

        if (requestParameters.uiRecipe !== undefined) {
            queryParameters['ui_recipe'] = requestParameters.uiRecipe;
        }

        if (requestParameters.attribute !== undefined) {
            queryParameters['attribute'] = requestParameters.attribute;
        }

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/documents-by-path/{data_source_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a document by it\'s path in the form \"{dataSource}/{rootPackage}/{subPackage(s)?/{name}
     * Get By Path
     */
    async documentGetByPath(requestParameters: DocumentGetByPathRequest): Promise<object> {
        const response = await this.documentGetByPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update
     */
    async documentUpdateRaw(requestParameters: DocumentUpdateRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling documentUpdate.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling documentUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling documentUpdate.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateUncontained !== undefined) {
            queryParameters['update_uncontained'] = requestParameters.updateUncontained;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.data !== undefined) {
            formParams.append('data', requestParameters.data as any);
        }

        if (requestParameters.attribute !== undefined) {
            formParams.append('attribute', requestParameters.attribute as any);
        }

        if (requestParameters.files) {
            requestParameters.files.forEach((element) => {
                formParams.append('files', element as any);
            })
        }

        const response = await this.request({
            path: `/api/v1/documents/{data_source_id}/{document_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Update
     */
    async documentUpdate(requestParameters: DocumentUpdateRequest): Promise<any> {
        const response = await this.documentUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Add a new document into an existing one. Must match it\'s parents attribute type. Select parent with format \'document_id.attribute.attribute\'
     * Add By Parent Id
     */
    async explorerAddRaw(requestParameters: ExplorerAddRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling explorerAdd.');
        }

        if (requestParameters.dottedId === null || requestParameters.dottedId === undefined) {
            throw new runtime.RequiredError('dottedId','Required parameter requestParameters.dottedId was null or undefined when calling explorerAdd.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling explorerAdd.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateUncontained !== undefined) {
            queryParameters['update_uncontained'] = requestParameters.updateUncontained;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/explorer/{data_source_id}/{dotted_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"dotted_id"}}`, encodeURIComponent(String(requestParameters.dottedId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Add a new document into an existing one. Must match it\'s parents attribute type. Select parent with format \'document_id.attribute.attribute\'
     * Add By Parent Id
     */
    async explorerAdd(requestParameters: ExplorerAddRequest): Promise<any> {
        const response = await this.explorerAddRaw(requestParameters);
        return await response.value();
    }

    /**
     * Add a RootPackage to the data source
     * Add Package
     */
    async explorerAddPackageRaw(requestParameters: ExplorerAddPackageRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling explorerAddPackage.');
        }

        if (requestParameters.addRootPackageRequest === null || requestParameters.addRootPackageRequest === undefined) {
            throw new runtime.RequiredError('addRootPackageRequest','Required parameter requestParameters.addRootPackageRequest was null or undefined when calling explorerAddPackage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/explorer/{data_source_id}/add-package`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddRootPackageRequestToJSON(requestParameters.addRootPackageRequest),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Add a RootPackage to the data source
     * Add Package
     */
    async explorerAddPackage(requestParameters: ExplorerAddPackageRequest): Promise<any> {
        const response = await this.explorerAddPackageRaw(requestParameters);
        return await response.value();
    }

    /**
     * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
     * Add Raw
     */
    async explorerAddSimpleRaw(requestParameters: ExplorerAddSimpleRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling explorerAddSimple.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling explorerAddSimple.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/explorer/{data_source_id}/add-raw`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
     * Add Raw
     */
    async explorerAddSimple(requestParameters: ExplorerAddSimpleRequest): Promise<any> {
        const response = await this.explorerAddSimpleRaw(requestParameters);
        return await response.value();
    }

    /**
     * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.
     * Add To Path
     */
    async explorerAddToPathRaw(requestParameters: ExplorerAddToPathRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling explorerAddToPath.');
        }

        if (requestParameters.document === null || requestParameters.document === undefined) {
            throw new runtime.RequiredError('document','Required parameter requestParameters.document was null or undefined when calling explorerAddToPath.');
        }

        if (requestParameters.directory === null || requestParameters.directory === undefined) {
            throw new runtime.RequiredError('directory','Required parameter requestParameters.directory was null or undefined when calling explorerAddToPath.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.document !== undefined) {
            formParams.append('document', requestParameters.document as any);
        }

        if (requestParameters.directory !== undefined) {
            formParams.append('directory', requestParameters.directory as any);
        }

        if (requestParameters.files) {
            requestParameters.files.forEach((element) => {
                formParams.append('files', element as any);
            })
        }

        const response = await this.request({
            path: `/api/v1/explorer/{data_source_id}/add-to-path`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.
     * Add To Path
     */
    async explorerAddToPath(requestParameters: ExplorerAddToPathRequest): Promise<any> {
        const response = await this.explorerAddToPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * Move
     */
    async explorerMoveRaw(requestParameters: ExplorerMoveRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling explorerMove.');
        }

        if (requestParameters.moveRequest === null || requestParameters.moveRequest === undefined) {
            throw new runtime.RequiredError('moveRequest','Required parameter requestParameters.moveRequest was null or undefined when calling explorerMove.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/explorer/{data_source_id}/move`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MoveRequestToJSON(requestParameters.moveRequest),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Move
     */
    async explorerMove(requestParameters: ExplorerMoveRequest): Promise<any> {
        const response = await this.explorerMoveRaw(requestParameters);
        return await response.value();
    }

    /**
     * Remove
     */
    async explorerRemoveRaw(requestParameters: ExplorerRemoveRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling explorerRemove.');
        }

        if (requestParameters.dottedId === null || requestParameters.dottedId === undefined) {
            throw new runtime.RequiredError('dottedId','Required parameter requestParameters.dottedId was null or undefined when calling explorerRemove.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/explorer/{data_source_id}/{dotted_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"dotted_id"}}`, encodeURIComponent(String(requestParameters.dottedId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Remove
     */
    async explorerRemove(requestParameters: ExplorerRemoveRequest): Promise<any> {
        const response = await this.explorerRemoveRaw(requestParameters);
        return await response.value();
    }

    /**
     * Remove By Path
     */
    async explorerRemoveByPathRaw(requestParameters: ExplorerRemoveByPathRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling explorerRemoveByPath.');
        }

        if (requestParameters.removeByPathRequest === null || requestParameters.removeByPathRequest === undefined) {
            throw new runtime.RequiredError('removeByPathRequest','Required parameter requestParameters.removeByPathRequest was null or undefined when calling explorerRemoveByPath.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/explorer/{data_source_id}/remove-by-path`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RemoveByPathRequestToJSON(requestParameters.removeByPathRequest),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Remove By Path
     */
    async explorerRemoveByPath(requestParameters: ExplorerRemoveByPathRequest): Promise<any> {
        const response = await this.explorerRemoveByPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * Rename
     */
    async explorerRenameRaw(requestParameters: ExplorerRenameRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling explorerRename.');
        }

        if (requestParameters.renameRequest === null || requestParameters.renameRequest === undefined) {
            throw new runtime.RequiredError('renameRequest','Required parameter requestParameters.renameRequest was null or undefined when calling explorerRename.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/explorer/{data_source_id}/rename`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RenameRequestToJSON(requestParameters.renameRequest),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Rename
     */
    async explorerRename(requestParameters: ExplorerRenameRequest): Promise<any> {
        const response = await this.explorerRenameRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get Acl
     */
    async getAclRaw(requestParameters: GetAclRequest): Promise<runtime.ApiResponse<ACL>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling getAcl.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling getAcl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/acl/{data_source_id}/{document_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ACLFromJSON(jsonValue));
    }

    /**
     * Get Acl
     */
    async getAcl(requestParameters: GetAclRequest): Promise<ACL> {
        const response = await this.getAclRaw(requestParameters);
        return await response.value();
    }

    /**
     * Healthcheck
     */
    async healthcheckRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/healthcheck`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Healthcheck
     */
    async healthcheck(): Promise<any> {
        const response = await this.healthcheckRaw();
        return await response.value();
    }

    /**
     * Delete Reference
     */
    async referenceDeleteRaw(requestParameters: ReferenceDeleteRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling referenceDelete.');
        }

        if (requestParameters.documentDottedId === null || requestParameters.documentDottedId === undefined) {
            throw new runtime.RequiredError('documentDottedId','Required parameter requestParameters.documentDottedId was null or undefined when calling referenceDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/reference/{data_source_id}/{document_dotted_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"document_dotted_id"}}`, encodeURIComponent(String(requestParameters.documentDottedId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete Reference
     */
    async referenceDelete(requestParameters: ReferenceDeleteRequest): Promise<object> {
        const response = await this.referenceDeleteRaw(requestParameters);
        return await response.value();
    }

    /**
     * Insert Reference
     */
    async referenceInsertRaw(requestParameters: ReferenceInsertRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling referenceInsert.');
        }

        if (requestParameters.documentDottedId === null || requestParameters.documentDottedId === undefined) {
            throw new runtime.RequiredError('documentDottedId','Required parameter requestParameters.documentDottedId was null or undefined when calling referenceInsert.');
        }

        if (requestParameters.reference === null || requestParameters.reference === undefined) {
            throw new runtime.RequiredError('reference','Required parameter requestParameters.reference was null or undefined when calling referenceInsert.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/reference/{data_source_id}/{document_dotted_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"document_dotted_id"}}`, encodeURIComponent(String(requestParameters.documentDottedId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReferenceToJSON(requestParameters.reference),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Insert Reference
     */
    async referenceInsert(requestParameters: ReferenceInsertRequest): Promise<object> {
        const response = await this.referenceInsertRaw(requestParameters);
        return await response.value();
    }

    /**
     * Search
     */
    async searchRaw(requestParameters: SearchRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling search.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling search.');
        }

        const queryParameters: any = {};

        if (requestParameters.sortByAttribute !== undefined) {
            queryParameters['sort_by_attribute'] = requestParameters.sortByAttribute;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/search/{data_source_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Search
     */
    async search(requestParameters: SearchRequest): Promise<object> {
        const response = await this.searchRaw(requestParameters);
        return await response.value();
    }

    /**
     * Set Acl
     */
    async setAclRaw(requestParameters: SetAclRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.dataSourceId === null || requestParameters.dataSourceId === undefined) {
            throw new runtime.RequiredError('dataSourceId','Required parameter requestParameters.dataSourceId was null or undefined when calling setAcl.');
        }

        if (requestParameters.documentId === null || requestParameters.documentId === undefined) {
            throw new runtime.RequiredError('documentId','Required parameter requestParameters.documentId was null or undefined when calling setAcl.');
        }

        if (requestParameters.aCL === null || requestParameters.aCL === undefined) {
            throw new runtime.RequiredError('aCL','Required parameter requestParameters.aCL was null or undefined when calling setAcl.');
        }

        const queryParameters: any = {};

        if (requestParameters.recursively !== undefined) {
            queryParameters['recursively'] = requestParameters.recursively;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/acl/{data_source_id}/{document_id}`.replace(`{${"data_source_id"}}`, encodeURIComponent(String(requestParameters.dataSourceId))).replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters.documentId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ACLToJSON(requestParameters.aCL),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Set Acl
     */
    async setAcl(requestParameters: SetAclRequest): Promise<object> {
        const response = await this.setAclRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get Personal Access Token
     */
    async tokenGetRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get Personal Access Token
     */
    async tokenGet(): Promise<any> {
        const response = await this.tokenGetRaw();
        return await response.value();
    }

    /**
     * Get Information On Authenticated User
     */
    async whoamiRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2AuthorizationCodeBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v1/whoami`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get Information On Authenticated User
     */
    async whoami(): Promise<any> {
        const response = await this.whoamiRaw();
        return await response.value();
    }

}
