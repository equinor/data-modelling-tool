/* tslint:disable */
/* eslint-disable */
/**
 * Data Modelling Storage Service
 * API for basic data modelling interaction
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ACL } from '../models';
// @ts-ignore
import { AccessLevel } from '../models';
// @ts-ignore
import { DataSourceRequest } from '../models';
// @ts-ignore
import { HTTPValidationError } from '../models';
// @ts-ignore
import { PATData } from '../models';
// @ts-ignore
import { Reference } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download a zip-folder of the requested root package
         * @summary Export
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (absoluteDocumentRef: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'absoluteDocumentRef' is not null or undefined
            assertParamExists('_export', 'absoluteDocumentRef', absoluteDocumentRef)
            const localVarPath = `/api/v1/export/{absolute_document_ref}`
                .replace(`{${"absolute_document_ref"}}`, encodeURIComponent(String(absoluteDocumentRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobGetById: async (dataSourceId: string, blobId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('blobGetById', 'dataSourceId', dataSourceId)
            // verify required parameter 'blobId' is not null or undefined
            assertParamExists('blobGetById', 'blobId', blobId)
            const localVarPath = `/api/v1/blobs/{data_source_id}/{blob_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"blob_id"}}`, encodeURIComponent(String(blobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobUpload: async (dataSourceId: string, blobId: string, file: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('blobUpload', 'dataSourceId', dataSourceId)
            // verify required parameter 'blobId' is not null or undefined
            assertParamExists('blobUpload', 'blobId', blobId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('blobUpload', 'file', file)
            const localVarPath = `/api/v1/blobs/{data_source_id}/{blob_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"blob_id"}}`, encodeURIComponent(String(blobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Blueprint of a type (including inherited attributes)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintGet: async (typeRef: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeRef' is not null or undefined
            assertParamExists('blueprintGet', 'typeRef', typeRef)
            const localVarPath = `/api/v1/blueprint/{type_ref}`
                .replace(`{${"type_ref"}}`, encodeURIComponent(String(typeRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve the data_source/uuid form of a blueprint to it\'s type path
         * @summary Resolve Blueprint Id
         * @param {string} absoluteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintResolve: async (absoluteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'absoluteId' is not null or undefined
            assertParamExists('blueprintResolve', 'absoluteId', absoluteId)
            const localVarPath = `/api/v1/resolve-path/{absolute_id}`
                .replace(`{${"absolute_id"}}`, encodeURIComponent(String(absoluteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGet: async (dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('dataSourceGet', 'dataSourceId', dataSourceId)
            const localVarPath = `/api/v1/data-sources/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGetAll: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a data source configuration
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceSave: async (dataSourceId: string, dataSourceRequest: DataSourceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('dataSourceSave', 'dataSourceId', dataSourceId)
            // verify required parameter 'dataSourceRequest' is not null or undefined
            assertParamExists('dataSourceSave', 'dataSourceRequest', dataSourceRequest)
            const localVarPath = `/api/v1/data-sources/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataSourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} [attribute] 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGetById: async (dataSourceId: string, documentId: string, attribute?: string, depth?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('documentGetById', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentGetById', 'documentId', documentId)
            const localVarPath = `/api/v1/documents/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (attribute !== undefined) {
                localVarQueryParameter['attribute'] = attribute;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a document by it\'s path in the form \"{dataSource}/{rootPackage}/{subPackage(s)?/{name}
         * @summary Get By Path
         * @param {string} dataSourceId 
         * @param {string} [attribute] 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGetByPath: async (dataSourceId: string, attribute?: string, path?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('documentGetByPath', 'dataSourceId', dataSourceId)
            const localVarPath = `/api/v1/documents-by-path/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (attribute !== undefined) {
                localVarQueryParameter['attribute'] = attribute;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {string} [attribute] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentUpdate: async (dataSourceId: string, documentId: string, data: string, updateUncontained?: boolean, attribute?: string, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('documentUpdate', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentUpdate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentUpdate', 'data', data)
            const localVarPath = `/api/v1/documents/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (updateUncontained !== undefined) {
                localVarQueryParameter['update_uncontained'] = updateUncontained;
            }


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (attribute !== undefined) { 
                localVarFormParams.append('attribute', attribute as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new document to absolute ref (root of data source, or another document). If added to another document, a valid attribute type check is done. Select parent with format \'data_source/document_id.attribute.index.attribute\'
         * @summary Add By Parent Id
         * @param {string} absoluteRef 
         * @param {object} body 
         * @param {boolean} [updateUncontained] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAdd: async (absoluteRef: string, body: object, updateUncontained?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'absoluteRef' is not null or undefined
            assertParamExists('explorerAdd', 'absoluteRef', absoluteRef)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('explorerAdd', 'body', body)
            const localVarPath = `/api/v1/explorer/{absolute_ref}`
                .replace(`{${"absolute_ref"}}`, encodeURIComponent(String(absoluteRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (updateUncontained !== undefined) {
                localVarQueryParameter['update_uncontained'] = updateUncontained;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAddSimple: async (dataSourceId: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('explorerAddSimple', 'dataSourceId', dataSourceId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('explorerAddSimple', 'body', body)
            const localVarPath = `/api/v1/explorer/{data_source_id}/add-raw`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.
         * @summary Add To Path
         * @param {string} dataSourceId 
         * @param {string} document 
         * @param {string} directory 
         * @param {boolean} [updateUncontained] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAddToPath: async (dataSourceId: string, document: string, directory: string, updateUncontained?: boolean, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('explorerAddToPath', 'dataSourceId', dataSourceId)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('explorerAddToPath', 'document', document)
            // verify required parameter 'directory' is not null or undefined
            assertParamExists('explorerAddToPath', 'directory', directory)
            const localVarPath = `/api/v1/explorer/{data_source_id}/add-to-path`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (updateUncontained !== undefined) {
                localVarQueryParameter['update_uncontained'] = updateUncontained;
            }


            if (document !== undefined) { 
                localVarFormParams.append('document', document as any);
            }
    
            if (directory !== undefined) { 
                localVarFormParams.append('directory', directory as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move
         * @param {string} dataSourceId 
         * @param {any} requestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerMove: async (dataSourceId: string, requestData: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('explorerMove', 'dataSourceId', dataSourceId)
            // verify required parameter 'requestData' is not null or undefined
            assertParamExists('explorerMove', 'requestData', requestData)
            const localVarPath = `/api/v1/explorer/{data_source_id}/move`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (requestData !== undefined) {
                localVarQueryParameter['request_data'] = requestData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove
         * @param {string} dataSourceId 
         * @param {string} dottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerRemove: async (dataSourceId: string, dottedId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('explorerRemove', 'dataSourceId', dataSourceId)
            // verify required parameter 'dottedId' is not null or undefined
            assertParamExists('explorerRemove', 'dottedId', dottedId)
            const localVarPath = `/api/v1/explorer/{data_source_id}/{dotted_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"dotted_id"}}`, encodeURIComponent(String(dottedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove By Path
         * @param {string} dataSourceId 
         * @param {string} directory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerRemoveByPath: async (dataSourceId: string, directory: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('explorerRemoveByPath', 'dataSourceId', dataSourceId)
            // verify required parameter 'directory' is not null or undefined
            assertParamExists('explorerRemoveByPath', 'directory', directory)
            const localVarPath = `/api/v1/explorer/{data_source_id}/remove-by-path`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (directory !== undefined) {
                localVarQueryParameter['directory'] = directory;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} parentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerRename: async (dataSourceId: string, documentId: string, parentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('explorerRename', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('explorerRename', 'documentId', documentId)
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('explorerRename', 'parentId', parentId)
            const localVarPath = `/api/v1/explorer/{data_source_id}/rename`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (documentId !== undefined) {
                localVarQueryParameter['document_id'] = documentId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcl: async (dataSourceId: string, documentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('getAcl', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getAcl', 'documentId', documentId)
            const localVarPath = `/api/v1/acl/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1HealthcheckGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDelete: async (dataSourceId: string, documentDottedId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('referenceDelete', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentDottedId' is not null or undefined
            assertParamExists('referenceDelete', 'documentDottedId', documentDottedId)
            const localVarPath = `/api/v1/reference/{data_source_id}/{document_dotted_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_dotted_id"}}`, encodeURIComponent(String(documentDottedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {Reference} reference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceInsert: async (dataSourceId: string, documentDottedId: string, reference: Reference, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('referenceInsert', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentDottedId' is not null or undefined
            assertParamExists('referenceInsert', 'documentDottedId', documentDottedId)
            // verify required parameter 'reference' is not null or undefined
            assertParamExists('referenceInsert', 'reference', reference)
            const localVarPath = `/api/v1/reference/{data_source_id}/{document_dotted_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_dotted_id"}}`, encodeURIComponent(String(documentDottedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search all data sources for the posted dictionary. If data source list is empty, search all databases.
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (body: object, dataSources?: Array<string>, sortByAttribute?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('search', 'body', body)
            const localVarPath = `/api/v1/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (dataSources) {
                localVarQueryParameter['data_sources'] = dataSources;
            }

            if (sortByAttribute !== undefined) {
                localVarQueryParameter['sort_by_attribute'] = sortByAttribute;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAcl: async (dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('setAcl', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('setAcl', 'documentId', documentId)
            // verify required parameter 'aCL' is not null or undefined
            assertParamExists('setAcl', 'aCL', aCL)
            const localVarPath = `/api/v1/acl/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (recursively !== undefined) {
                localVarQueryParameter['recursively'] = recursively;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aCL, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate: async (scope?: AccessLevel, timeToLive?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (timeToLive !== undefined) {
                localVarQueryParameter['time_to_live'] = timeToLive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete: async (tokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokenDelete', 'tokenId', tokenId)
            const localVarPath = `/api/v1/token/{token_id}`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenListAll: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Download a zip-folder of the requested root package
         * @summary Export
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(absoluteDocumentRef: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(absoluteDocumentRef, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blobGetById(dataSourceId: string, blobId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blobGetById(dataSourceId, blobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blobUpload(dataSourceId: string, blobId: string, file: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blobUpload(dataSourceId, blobId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the Blueprint of a type (including inherited attributes)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blueprintGet(typeRef: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blueprintGet(typeRef, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolve the data_source/uuid form of a blueprint to it\'s type path
         * @summary Resolve Blueprint Id
         * @param {string} absoluteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blueprintResolve(absoluteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blueprintResolve(absoluteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceGet(dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceGet(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceGetAll(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update a data source configuration
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceSave(dataSourceId: string, dataSourceRequest: DataSourceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceSave(dataSourceId, dataSourceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} [attribute] 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentGetById(dataSourceId: string, documentId: string, attribute?: string, depth?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentGetById(dataSourceId, documentId, attribute, depth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a document by it\'s path in the form \"{dataSource}/{rootPackage}/{subPackage(s)?/{name}
         * @summary Get By Path
         * @param {string} dataSourceId 
         * @param {string} [attribute] 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentGetByPath(dataSourceId: string, attribute?: string, path?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentGetByPath(dataSourceId, attribute, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {string} [attribute] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentUpdate(dataSourceId: string, documentId: string, data: string, updateUncontained?: boolean, attribute?: string, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentUpdate(dataSourceId, documentId, data, updateUncontained, attribute, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new document to absolute ref (root of data source, or another document). If added to another document, a valid attribute type check is done. Select parent with format \'data_source/document_id.attribute.index.attribute\'
         * @summary Add By Parent Id
         * @param {string} absoluteRef 
         * @param {object} body 
         * @param {boolean} [updateUncontained] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerAdd(absoluteRef: string, body: object, updateUncontained?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerAdd(absoluteRef, body, updateUncontained, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerAddSimple(dataSourceId: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerAddSimple(dataSourceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.
         * @summary Add To Path
         * @param {string} dataSourceId 
         * @param {string} document 
         * @param {string} directory 
         * @param {boolean} [updateUncontained] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerAddToPath(dataSourceId: string, document: string, directory: string, updateUncontained?: boolean, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerAddToPath(dataSourceId, document, directory, updateUncontained, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move
         * @param {string} dataSourceId 
         * @param {any} requestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerMove(dataSourceId: string, requestData: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerMove(dataSourceId, requestData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove
         * @param {string} dataSourceId 
         * @param {string} dottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerRemove(dataSourceId: string, dottedId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerRemove(dataSourceId, dottedId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove By Path
         * @param {string} dataSourceId 
         * @param {string} directory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerRemoveByPath(dataSourceId: string, directory: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerRemoveByPath(dataSourceId, directory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rename
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} parentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explorerRename(dataSourceId: string, documentId: string, parentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explorerRename(dataSourceId, documentId, parentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAcl(dataSourceId: string, documentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ACL>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAcl(dataSourceId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1HealthcheckGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1HealthcheckGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referenceDelete(dataSourceId: string, documentDottedId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referenceDelete(dataSourceId, documentDottedId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Insert Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {Reference} reference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referenceInsert(dataSourceId: string, documentDottedId: string, reference: Reference, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referenceInsert(dataSourceId, documentDottedId, reference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search all data sources for the posted dictionary. If data source list is empty, search all databases.
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(body: object, dataSources?: Array<string>, sortByAttribute?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(body, dataSources, sortByAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAcl(dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAcl(dataSourceId, documentId, aCL, recursively, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenCreate(scope?: AccessLevel, timeToLive?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenCreate(scope, timeToLive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDelete(tokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenListAll(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PATData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenListAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Download a zip-folder of the requested root package
         * @summary Export
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(absoluteDocumentRef: string, options?: any): AxiosPromise<void> {
            return localVarFp._export(absoluteDocumentRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobGetById(dataSourceId: string, blobId: string, options?: any): AxiosPromise<any> {
            return localVarFp.blobGetById(dataSourceId, blobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobUpload(dataSourceId: string, blobId: string, file: any, options?: any): AxiosPromise<string> {
            return localVarFp.blobUpload(dataSourceId, blobId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Blueprint of a type (including inherited attributes)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintGet(typeRef: string, options?: any): AxiosPromise<object> {
            return localVarFp.blueprintGet(typeRef, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolve the data_source/uuid form of a blueprint to it\'s type path
         * @summary Resolve Blueprint Id
         * @param {string} absoluteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintResolve(absoluteId: string, options?: any): AxiosPromise<string> {
            return localVarFp.blueprintResolve(absoluteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGet(dataSourceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.dataSourceGet(dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGetAll(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.dataSourceGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a data source configuration
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceSave(dataSourceId: string, dataSourceRequest: DataSourceRequest, options?: any): AxiosPromise<string> {
            return localVarFp.dataSourceSave(dataSourceId, dataSourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} [attribute] 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGetById(dataSourceId: string, documentId: string, attribute?: string, depth?: number, options?: any): AxiosPromise<object> {
            return localVarFp.documentGetById(dataSourceId, documentId, attribute, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a document by it\'s path in the form \"{dataSource}/{rootPackage}/{subPackage(s)?/{name}
         * @summary Get By Path
         * @param {string} dataSourceId 
         * @param {string} [attribute] 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGetByPath(dataSourceId: string, attribute?: string, path?: string, options?: any): AxiosPromise<object> {
            return localVarFp.documentGetByPath(dataSourceId, attribute, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {string} [attribute] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentUpdate(dataSourceId: string, documentId: string, data: string, updateUncontained?: boolean, attribute?: string, files?: Array<any>, options?: any): AxiosPromise<any> {
            return localVarFp.documentUpdate(dataSourceId, documentId, data, updateUncontained, attribute, files, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new document to absolute ref (root of data source, or another document). If added to another document, a valid attribute type check is done. Select parent with format \'data_source/document_id.attribute.index.attribute\'
         * @summary Add By Parent Id
         * @param {string} absoluteRef 
         * @param {object} body 
         * @param {boolean} [updateUncontained] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAdd(absoluteRef: string, body: object, updateUncontained?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.explorerAdd(absoluteRef, body, updateUncontained, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAddSimple(dataSourceId: string, body: object, options?: any): AxiosPromise<string> {
            return localVarFp.explorerAddSimple(dataSourceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.
         * @summary Add To Path
         * @param {string} dataSourceId 
         * @param {string} document 
         * @param {string} directory 
         * @param {boolean} [updateUncontained] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAddToPath(dataSourceId: string, document: string, directory: string, updateUncontained?: boolean, files?: Array<any>, options?: any): AxiosPromise<object> {
            return localVarFp.explorerAddToPath(dataSourceId, document, directory, updateUncontained, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move
         * @param {string} dataSourceId 
         * @param {any} requestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerMove(dataSourceId: string, requestData: any, options?: any): AxiosPromise<string> {
            return localVarFp.explorerMove(dataSourceId, requestData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove
         * @param {string} dataSourceId 
         * @param {string} dottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerRemove(dataSourceId: string, dottedId: string, options?: any): AxiosPromise<string> {
            return localVarFp.explorerRemove(dataSourceId, dottedId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove By Path
         * @param {string} dataSourceId 
         * @param {string} directory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerRemoveByPath(dataSourceId: string, directory: string, options?: any): AxiosPromise<any> {
            return localVarFp.explorerRemoveByPath(dataSourceId, directory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} parentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerRename(dataSourceId: string, documentId: string, parentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.explorerRename(dataSourceId, documentId, parentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcl(dataSourceId: string, documentId: string, options?: any): AxiosPromise<ACL> {
            return localVarFp.getAcl(dataSourceId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1HealthcheckGet(options?: any): AxiosPromise<string> {
            return localVarFp.getApiV1HealthcheckGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDelete(dataSourceId: string, documentDottedId: string, options?: any): AxiosPromise<object> {
            return localVarFp.referenceDelete(dataSourceId, documentDottedId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Insert Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {Reference} reference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceInsert(dataSourceId: string, documentDottedId: string, reference: Reference, options?: any): AxiosPromise<object> {
            return localVarFp.referenceInsert(dataSourceId, documentDottedId, reference, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search all data sources for the posted dictionary. If data source list is empty, search all databases.
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(body: object, dataSources?: Array<string>, sortByAttribute?: string, options?: any): AxiosPromise<object> {
            return localVarFp.search(body, dataSources, sortByAttribute, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAcl(dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.setAcl(dataSourceId, documentId, aCL, recursively, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate(scope?: AccessLevel, timeToLive?: number, options?: any): AxiosPromise<string> {
            return localVarFp.tokenCreate(scope, timeToLive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete(tokenId: string, options?: any): AxiosPromise<string> {
            return localVarFp.tokenDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenListAll(options?: any): AxiosPromise<Array<PATData>> {
            return localVarFp.tokenListAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): AxiosPromise<any> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _export operation in DefaultApi.
 * @export
 * @interface DefaultApiExportRequest
 */
export interface DefaultApiExportRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExport
     */
    readonly absoluteDocumentRef: string
}

/**
 * Request parameters for blobGetById operation in DefaultApi.
 * @export
 * @interface DefaultApiBlobGetByIdRequest
 */
export interface DefaultApiBlobGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobGetById
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobGetById
     */
    readonly blobId: string
}

/**
 * Request parameters for blobUpload operation in DefaultApi.
 * @export
 * @interface DefaultApiBlobUploadRequest
 */
export interface DefaultApiBlobUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobUpload
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobUpload
     */
    readonly blobId: string

    /**
     * 
     * @type {any}
     * @memberof DefaultApiBlobUpload
     */
    readonly file: any
}

/**
 * Request parameters for blueprintGet operation in DefaultApi.
 * @export
 * @interface DefaultApiBlueprintGetRequest
 */
export interface DefaultApiBlueprintGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlueprintGet
     */
    readonly typeRef: string
}

/**
 * Request parameters for blueprintResolve operation in DefaultApi.
 * @export
 * @interface DefaultApiBlueprintResolveRequest
 */
export interface DefaultApiBlueprintResolveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlueprintResolve
     */
    readonly absoluteId: string
}

/**
 * Request parameters for dataSourceGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDataSourceGetRequest
 */
export interface DefaultApiDataSourceGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDataSourceGet
     */
    readonly dataSourceId: string
}

/**
 * Request parameters for dataSourceSave operation in DefaultApi.
 * @export
 * @interface DefaultApiDataSourceSaveRequest
 */
export interface DefaultApiDataSourceSaveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDataSourceSave
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {DataSourceRequest}
     * @memberof DefaultApiDataSourceSave
     */
    readonly dataSourceRequest: DataSourceRequest
}

/**
 * Request parameters for documentGetById operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentGetByIdRequest
 */
export interface DefaultApiDocumentGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGetById
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGetById
     */
    readonly documentId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGetById
     */
    readonly attribute?: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiDocumentGetById
     */
    readonly depth?: number
}

/**
 * Request parameters for documentGetByPath operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentGetByPathRequest
 */
export interface DefaultApiDocumentGetByPathRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGetByPath
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGetByPath
     */
    readonly attribute?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGetByPath
     */
    readonly path?: string
}

/**
 * Request parameters for documentUpdate operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentUpdateRequest
 */
export interface DefaultApiDocumentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly documentId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly data: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly updateUncontained?: boolean

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly attribute?: string

    /**
     * 
     * @type {Array<any>}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly files?: Array<any>
}

/**
 * Request parameters for explorerAdd operation in DefaultApi.
 * @export
 * @interface DefaultApiExplorerAddRequest
 */
export interface DefaultApiExplorerAddRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerAdd
     */
    readonly absoluteRef: string

    /**
     * 
     * @type {object}
     * @memberof DefaultApiExplorerAdd
     */
    readonly body: object

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiExplorerAdd
     */
    readonly updateUncontained?: boolean
}

/**
 * Request parameters for explorerAddSimple operation in DefaultApi.
 * @export
 * @interface DefaultApiExplorerAddSimpleRequest
 */
export interface DefaultApiExplorerAddSimpleRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerAddSimple
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {object}
     * @memberof DefaultApiExplorerAddSimple
     */
    readonly body: object
}

/**
 * Request parameters for explorerAddToPath operation in DefaultApi.
 * @export
 * @interface DefaultApiExplorerAddToPathRequest
 */
export interface DefaultApiExplorerAddToPathRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerAddToPath
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerAddToPath
     */
    readonly document: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerAddToPath
     */
    readonly directory: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiExplorerAddToPath
     */
    readonly updateUncontained?: boolean

    /**
     * 
     * @type {Array<any>}
     * @memberof DefaultApiExplorerAddToPath
     */
    readonly files?: Array<any>
}

/**
 * Request parameters for explorerMove operation in DefaultApi.
 * @export
 * @interface DefaultApiExplorerMoveRequest
 */
export interface DefaultApiExplorerMoveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerMove
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {any}
     * @memberof DefaultApiExplorerMove
     */
    readonly requestData: any
}

/**
 * Request parameters for explorerRemove operation in DefaultApi.
 * @export
 * @interface DefaultApiExplorerRemoveRequest
 */
export interface DefaultApiExplorerRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerRemove
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerRemove
     */
    readonly dottedId: string
}

/**
 * Request parameters for explorerRemoveByPath operation in DefaultApi.
 * @export
 * @interface DefaultApiExplorerRemoveByPathRequest
 */
export interface DefaultApiExplorerRemoveByPathRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerRemoveByPath
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerRemoveByPath
     */
    readonly directory: string
}

/**
 * Request parameters for explorerRename operation in DefaultApi.
 * @export
 * @interface DefaultApiExplorerRenameRequest
 */
export interface DefaultApiExplorerRenameRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerRename
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerRename
     */
    readonly documentId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiExplorerRename
     */
    readonly parentId: string
}

/**
 * Request parameters for getAcl operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAclRequest
 */
export interface DefaultApiGetAclRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetAcl
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetAcl
     */
    readonly documentId: string
}

/**
 * Request parameters for referenceDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiReferenceDeleteRequest
 */
export interface DefaultApiReferenceDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceDelete
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceDelete
     */
    readonly documentDottedId: string
}

/**
 * Request parameters for referenceInsert operation in DefaultApi.
 * @export
 * @interface DefaultApiReferenceInsertRequest
 */
export interface DefaultApiReferenceInsertRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceInsert
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceInsert
     */
    readonly documentDottedId: string

    /**
     * 
     * @type {Reference}
     * @memberof DefaultApiReferenceInsert
     */
    readonly reference: Reference
}

/**
 * Request parameters for search operation in DefaultApi.
 * @export
 * @interface DefaultApiSearchRequest
 */
export interface DefaultApiSearchRequest {
    /**
     * 
     * @type {object}
     * @memberof DefaultApiSearch
     */
    readonly body: object

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiSearch
     */
    readonly dataSources?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSearch
     */
    readonly sortByAttribute?: string
}

/**
 * Request parameters for setAcl operation in DefaultApi.
 * @export
 * @interface DefaultApiSetAclRequest
 */
export interface DefaultApiSetAclRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSetAcl
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSetAcl
     */
    readonly documentId: string

    /**
     * 
     * @type {ACL}
     * @memberof DefaultApiSetAcl
     */
    readonly aCL: ACL

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiSetAcl
     */
    readonly recursively?: boolean
}

/**
 * Request parameters for tokenCreate operation in DefaultApi.
 * @export
 * @interface DefaultApiTokenCreateRequest
 */
export interface DefaultApiTokenCreateRequest {
    /**
     * 
     * @type {AccessLevel}
     * @memberof DefaultApiTokenCreate
     */
    readonly scope?: AccessLevel

    /**
     * 
     * @type {number}
     * @memberof DefaultApiTokenCreate
     */
    readonly timeToLive?: number
}

/**
 * Request parameters for tokenDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiTokenDeleteRequest
 */
export interface DefaultApiTokenDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiTokenDelete
     */
    readonly tokenId: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Download a zip-folder of the requested root package
     * @summary Export
     * @param {DefaultApiExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _export(requestParameters: DefaultApiExportRequest, options?: any) {
        return DefaultApiFp(this.configuration)._export(requestParameters.absoluteDocumentRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get By Id
     * @param {DefaultApiBlobGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blobGetById(requestParameters: DefaultApiBlobGetByIdRequest, options?: any) {
        return DefaultApiFp(this.configuration).blobGetById(requestParameters.dataSourceId, requestParameters.blobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload
     * @param {DefaultApiBlobUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blobUpload(requestParameters: DefaultApiBlobUploadRequest, options?: any) {
        return DefaultApiFp(this.configuration).blobUpload(requestParameters.dataSourceId, requestParameters.blobId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the Blueprint of a type (including inherited attributes)
     * @summary Get Blueprint
     * @param {DefaultApiBlueprintGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blueprintGet(requestParameters: DefaultApiBlueprintGetRequest, options?: any) {
        return DefaultApiFp(this.configuration).blueprintGet(requestParameters.typeRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolve the data_source/uuid form of a blueprint to it\'s type path
     * @summary Resolve Blueprint Id
     * @param {DefaultApiBlueprintResolveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blueprintResolve(requestParameters: DefaultApiBlueprintResolveRequest, options?: any) {
        return DefaultApiFp(this.configuration).blueprintResolve(requestParameters.absoluteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get
     * @param {DefaultApiDataSourceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceGet(requestParameters: DefaultApiDataSourceGetRequest, options?: any) {
        return DefaultApiFp(this.configuration).dataSourceGet(requestParameters.dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceGetAll(options?: any) {
        return DefaultApiFp(this.configuration).dataSourceGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a data source configuration
     * @summary Save
     * @param {DefaultApiDataSourceSaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceSave(requestParameters: DefaultApiDataSourceSaveRequest, options?: any) {
        return DefaultApiFp(this.configuration).dataSourceSave(requestParameters.dataSourceId, requestParameters.dataSourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get By Id
     * @param {DefaultApiDocumentGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentGetById(requestParameters: DefaultApiDocumentGetByIdRequest, options?: any) {
        return DefaultApiFp(this.configuration).documentGetById(requestParameters.dataSourceId, requestParameters.documentId, requestParameters.attribute, requestParameters.depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a document by it\'s path in the form \"{dataSource}/{rootPackage}/{subPackage(s)?/{name}
     * @summary Get By Path
     * @param {DefaultApiDocumentGetByPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentGetByPath(requestParameters: DefaultApiDocumentGetByPathRequest, options?: any) {
        return DefaultApiFp(this.configuration).documentGetByPath(requestParameters.dataSourceId, requestParameters.attribute, requestParameters.path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {DefaultApiDocumentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentUpdate(requestParameters: DefaultApiDocumentUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).documentUpdate(requestParameters.dataSourceId, requestParameters.documentId, requestParameters.data, requestParameters.updateUncontained, requestParameters.attribute, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new document to absolute ref (root of data source, or another document). If added to another document, a valid attribute type check is done. Select parent with format \'data_source/document_id.attribute.index.attribute\'
     * @summary Add By Parent Id
     * @param {DefaultApiExplorerAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public explorerAdd(requestParameters: DefaultApiExplorerAddRequest, options?: any) {
        return DefaultApiFp(this.configuration).explorerAdd(requestParameters.absoluteRef, requestParameters.body, requestParameters.updateUncontained, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
     * @summary Add Raw
     * @param {DefaultApiExplorerAddSimpleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public explorerAddSimple(requestParameters: DefaultApiExplorerAddSimpleRequest, options?: any) {
        return DefaultApiFp(this.configuration).explorerAddSimple(requestParameters.dataSourceId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.
     * @summary Add To Path
     * @param {DefaultApiExplorerAddToPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public explorerAddToPath(requestParameters: DefaultApiExplorerAddToPathRequest, options?: any) {
        return DefaultApiFp(this.configuration).explorerAddToPath(requestParameters.dataSourceId, requestParameters.document, requestParameters.directory, requestParameters.updateUncontained, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move
     * @param {DefaultApiExplorerMoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public explorerMove(requestParameters: DefaultApiExplorerMoveRequest, options?: any) {
        return DefaultApiFp(this.configuration).explorerMove(requestParameters.dataSourceId, requestParameters.requestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove
     * @param {DefaultApiExplorerRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public explorerRemove(requestParameters: DefaultApiExplorerRemoveRequest, options?: any) {
        return DefaultApiFp(this.configuration).explorerRemove(requestParameters.dataSourceId, requestParameters.dottedId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove By Path
     * @param {DefaultApiExplorerRemoveByPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public explorerRemoveByPath(requestParameters: DefaultApiExplorerRemoveByPathRequest, options?: any) {
        return DefaultApiFp(this.configuration).explorerRemoveByPath(requestParameters.dataSourceId, requestParameters.directory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename
     * @param {DefaultApiExplorerRenameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public explorerRename(requestParameters: DefaultApiExplorerRenameRequest, options?: any) {
        return DefaultApiFp(this.configuration).explorerRename(requestParameters.dataSourceId, requestParameters.documentId, requestParameters.parentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Acl
     * @param {DefaultApiGetAclRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAcl(requestParameters: DefaultApiGetAclRequest, options?: any) {
        return DefaultApiFp(this.configuration).getAcl(requestParameters.dataSourceId, requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1HealthcheckGet(options?: any) {
        return DefaultApiFp(this.configuration).getApiV1HealthcheckGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Reference
     * @param {DefaultApiReferenceDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public referenceDelete(requestParameters: DefaultApiReferenceDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).referenceDelete(requestParameters.dataSourceId, requestParameters.documentDottedId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Insert Reference
     * @param {DefaultApiReferenceInsertRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public referenceInsert(requestParameters: DefaultApiReferenceInsertRequest, options?: any) {
        return DefaultApiFp(this.configuration).referenceInsert(requestParameters.dataSourceId, requestParameters.documentDottedId, requestParameters.reference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a list of data source id\'s as a query parameter, and search all data sources for the posted dictionary. If data source list is empty, search all databases.
     * @summary Search
     * @param {DefaultApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public search(requestParameters: DefaultApiSearchRequest, options?: any) {
        return DefaultApiFp(this.configuration).search(requestParameters.body, requestParameters.dataSources, requestParameters.sortByAttribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Acl
     * @param {DefaultApiSetAclRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setAcl(requestParameters: DefaultApiSetAclRequest, options?: any) {
        return DefaultApiFp(this.configuration).setAcl(requestParameters.dataSourceId, requestParameters.documentId, requestParameters.aCL, requestParameters.recursively, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary New Personal Access Token
     * @param {DefaultApiTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenCreate(requestParameters: DefaultApiTokenCreateRequest = {}, options?: any) {
        return DefaultApiFp(this.configuration).tokenCreate(requestParameters.scope, requestParameters.timeToLive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke Personal Access Token
     * @param {DefaultApiTokenDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenDelete(requestParameters: DefaultApiTokenDeleteRequest, options?: any) {
        return DefaultApiFp(this.configuration).tokenDelete(requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List All Pats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenListAll(options?: any) {
        return DefaultApiFp(this.configuration).tokenListAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Information On Authenticated User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public whoami(options?: any) {
        return DefaultApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}
